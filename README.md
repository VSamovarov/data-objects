# Документація для модуля `Sam\DataObjects`

## Опис модуля

Модуль забезпечує основу для роботи з об'єктами передачі даних (Data Transfer Objects - DTO). Він включає класи,
інтерфейси, трейти й спеціальні механізми для автоматизованої серіалізації, кастомізації властивостей, а також захищає
від проблем, пов’язаних із круговими посиланнями. `Sam\DataObjects`

### Особливості:

- **Автоматична серіалізація** об'єктів у масиви чи JSON.
- **Підтримка кастомних конвертерів** (кастерів) для перетворень властивостей DTO.
- **Механізм виключення властивостей із серіалізації** за умов типу чи значення.
- **Інтеграція з Laravel** через спеціального сервіс-провайдера.

## Установка

1. **Встановлення через Laravel Service Provider:** Додайте до вашого Laravel-додатку у :
   `DtoServiceProvider``config/app.php`

``` php
   'providers' => [
       // Інші провайдери
       Sam\DataObjects\DtoServiceProvider::class,
   ],
```

1. **Інжектування PropertyExtractor:** Інструмент автоматично зареєстрований як сінглтон через . Жодних додаткових дій
   не потрібно. `DtoServiceProvider`

## Основні класи та функціонал

### 1. **`DtoServiceProvider`**

відповідає за реєстрацію синглтона для роботи з каскадним отриманням властивостей у класах DTO. Він забезпечує
оптимізацію доступу до властивостей за рахунок кешування. `DtoServiceProvider`
**Реєстрація:**

- реєструється як синглтон зі ввімкненим кешуванням, що зменшує навантаження під час роботи з `Reflection` у великих
  проєктах. `PropertyExtractor`

### 2. **`PropertyExtractor`**

— клас, який займається аналізом та вилученням інформації про властивості класів DTO. `PropertyExtractor`

#### Головні особливості:

- **Підтримка різних стилів DTO:**
    - Параметри з конструктора (). `public function __construct(public int $id)`
    - Легасі-стиль ( + конструктор). `public int $id;`

- **Кешування результатів:**
  Автоматично кешує результати для прискорення повторних викликів.
- **Валідація структури DTO:**
  Впроваджено строгі перевірки, які недопускають помилок у змішаних стилях визначення властивостей.
- **Робота через рефлексію:**
  Використовує `Reflection API` для аналізу класів і забезпечення гнучкої структуризації даних.

#### Методи:

- **`getProperties(object|string $classOrObject): array`**
  Отримує масив властивостей DTO у вигляді об’єктів .
  Підтримує кешування та може обробляти як імена класів, так і екземпляри. `DtoProperty`
- **`clearCache(?string $class = null): void`**
  Очищає кеш для конкретного класу або для всіх класів.

#### Використання:

Статичний екземпляр дозволяє зручно отримувати опис всіх властивостей DTO та їхні параметри. Це особливо корисно для
серіалізації, валідації чи документування. `PropertyExtractor`

### 3. **`SerializableContext`**

— це клас для управління контекстом під час серіалізації об'єктів до масивів. `SerializableContext`

#### Головні особливості:

- **Контроль кругових посилань:**
  Виявляє кругові залежності під час серіалізації складних графів об’єктів. Запобігає "затору" або нескінченним циклам
  серіалізації.
- **Ізольований контекст:**
  Кожна серіалізація має ізольований об’єкт контексту для забезпечення багатопотокової безпеки.
- **Використання `WeakMap`:**
  Для ефективного відслідковування вже оброблених об'єктів.

#### Методи:

- **`has(object $obj): bool`**
  Перевіряє, чи об'єкт уже був зареєстрований у поточному контексті.
- **`attach(object $obj): void`**
  Додає об'єкт до контексту.
- **`detach(object $obj): void`**
  Видаляє об'єкт з контексту.
- **`startCircularDetect(object $obj): void`**
  Починає цикл перевірки. Якщо об'єкт повторюється, викидає виняток `CircularReferenceException`.
- **`endCircularDetect(object $obj): void`**
  Завершує цикл перевірки та забирає об'єкт із контексту.

#### Використання:

інтегровано до методу всіх класів DTO. Він запобігає рекурсії у разі складних ієрархій об'єктів. Це особливо важливо для
гарантованої безпеки у великих проєктах. `SerializableContext``toArray()`

## Приклади використання

### Крок 1: Реєстрація `DtoServiceProvider`

У вашому Laravel-додатку реєструємо провайдера.

``` php
// config/app.php

'providers' => [
    Sam\DataObjects\DtoServiceProvider::class,
];
```

### Крок 2: Використання DTO

``` php
use Sam\DataObjects\AbstractDto;

final class UserDto extends AbstractDto 
{
    public function __construct(
        public readonly int $id,
        public readonly string $name,
        public readonly ?string $email = null
    ) {}
}

// Створення DTO
$userDto = new UserDto(id: 1, name: 'John Doe');

// Серіалізація
$array = $userDto->toArray();
$json = json_encode($userDto);
```

### Крок 3: Робота із `PropertyExtractor`

``` php
// Використання PropertyExtractor
$extractor = app(PropertyExtractor::class);

// Отримання властивостей класу
$properties = $extractor->getProperties(UserDto::class);

// Очищення кешу
$extractor->clearCache(UserDto::class);
```

### Крок 4: Перевірка на кругові залежності

``` php
use Sam\DataObjects\SerializableContext;

$context = new SerializableContext();

try {
    $object = new SomeDto();
    
    // Старт перевірки
    $context->startCircularDetect($object);
    
    // Серіалізація логіки...
    
    // Завершення
    $context->endCircularDetect($object);
} catch (\Sam\DataObjects\Exceptions\CircularReferenceException $e) {
    echo $e->getMessage();
}
```

### 4. **`SerializableResolver`**

`SerializableResolver` — це фінальний клас, відповідальний за процес серіалізації об'єктів DTO у масиви. Він працює з
кастерами, властивостями об'єктів та контекстом серіалізації для забезпечення гнучкого й безпечного перетворення даних.

---

#### Головні особливості:

1. **Робота з властивостями DTO:**
   Використовує `PropertyExtractor` для отримання повної інформації про властивості класу DTO.

2. **Взаємодія з кастерами:**
    - Може застосовувати кастери на глобальному рівні.
    - Підтримує кастери, визначені на рівні окремих атрибутів властивостей.

3. **Обробка кругових посилань:**
    - Інтегрується з `SerializableContext` для перевірки й уникнення циклічних залежностей під час серіалізації.

4. **Рекурсивна серіалізація:**
    - Обробляє вкладені (в тому числі ітеративні) структури даних, властивості яких можуть містити інші об'єкти або
      ітератори.

5. **Фільтрація властивостей:**
   Може виключати властивості з серіалізації, якщо вони відповідають певним умовам, реалізованим через інтерфейс
   `SkipsSerialization`.

---

#### Основні методи:

- **`resolve(AutoSerializableInterface $object, SerializableContext $context): mixed`**
  Основний метод для серіалізації об'єкта DTO.  
  Виконує такі кроки:
    - Ініціалізує перевірку на циклічні залежності.
    - Витягує властивості DTO за допомогою `PropertyExtractor`.
    - Застосовує фільтри й кастери до властивостей.
    - Рекурсивно серіалізує вкладені об'єкти.

- **`resolveRecursively(mixed $value, SerializableContext $context): mixed`**
  Використовується для рекурсивної обробки даних:
    - Якщо значення є об'єктом, що реалізує `AutoSerializableInterface`, автоматично серіалізує його.
    - Якщо значення є ітератором — обробляє кожен елемент.
    - Якщо значення є простим типом, застосовує глобальні кастери.

- **`shouldSkipProperty(mixed $value, DtoProperty $dtoProp): bool`**
  Перевіряє, чи потрібно виключити властивість із серіалізації відповідно до її атрибутів або кастерів, що реалізують
  `SkipsSerialization`.

- **`getCastersFromAttributes(DtoProperty $dtoProp): array`**
  Повертає список кастерів, визначених через атрибути властивості.

---

#### Приклад використання:

```php
use Sam\DataObjects\SerializableResolver;
use Sam\DataObjects\SerializableContext;
use Sam\DataObjects\Contracts\AutoSerializable;

// Об'єкт DTO
class ExampleDto implements AutoSerializable {
    public function __construct(public string $name, public int $value) {}
    
    public function autoSerializable(SerializableContext $context): mixed {
        $resolver = new SerializableResolver(
            globalCasters: [/* Список глобальних кастерів */], 
            propertyExtractor: new PropertyExtractor()
        );
        return $resolver->resolve($this, $context);
    }
}

// Приклад серіалізації
$dto = new ExampleDto('example', 42);
$context = new SerializableContext();
$resolver = new SerializableResolver(globalCasters: [], propertyExtractor: new PropertyExtractor());

$serialized = $resolver->resolve($dto, $context);
print_r($serialized);
// Output: ['name' => 'example', 'value' => 42]
```

---

#### Використання у проекті:

- Викликається автоматично через методи `autoSerializable()` у DTO-класах.
- Забезпечує єдиний механізм серіалізації із врахуванням кастерів, виключень та вкладених структур.
- Інтегрується з інструментами модуля через глобальні (`AutoSerializableTrait`) і локальні серіалізаційні правила (
  `SkipsSerialization`, кастери).

---

`SerializableResolver` забезпечує простий та ефективний підхід до серіалізації даних, надаючи розробнику повний контроль
за перетворенням властивостей й даних DTO без втрати продуктивності або гнучкості.

### 5. **`FromArrayTrait`**

`FromArrayTrait` — це трейд, який забезпечує зручний спосіб створення об'єктів класу із масиву даних. Даний механізм
корисний у сценаріях, де необхідно заповнити DTO з отриманих даних, наприклад, із запитів або відповіді API.

#### Основна функціональність:

1. **Метод `fromArray`:**
    - Приймає масив даних (`array<string, mixed>`).
    - Повертає новий екземпляр об'єкта з даними, що відповідають властивостям класу.
    - Включає обробку вкладених об'єктів та перевірку обов'язкових полів.

#### Особливості:

- Автоматичне співставлення властивостей класу з ключами масиву.
- Підтримка складних типів та вкладених об'єктів, які реалізують інтерфейс `FromArray`.
- Кидання виключень для відсутніх обов'язкових властивостей або помилок у відображенні структури.

### 6. `EquatableTrait`

`EquatableTrait` — це трейт, призначений для реалізації логіки перевірки рівності об’єктів, що належать до одного класу.
Він порівнює об’єкти на основі значень їхніх властивостей і забезпечує, що два об’єкти вважаються рівними, якщо значення
їхніх властивостей ідентичні.

#### Основні можливості:

1. **Комплексне порівняння властивостей:**
    - Порівнює всі властивості двох об’єктів, включаючи вкладені об’єкти та масиви.
    - Забезпечує відповідність типів і класів властивостей під час порівняння.

2. **Підтримка кастомної логіки рівності:**
    - Якщо властивість реалізує інтерфейс `Equatable` або має метод `equals`, для визначення рівності використовується
      ця кастомна логіка.

3. **Глибоке і гнучке порівняння:**
    - Здійснює глибоке порівняння об’єктів і масивів, якщо відсутня кастомна логіка.
    - Використовує перетворення в послідовність (серіалізацію) для строгого порівняння, коли це необхідно.

4. **Клас-специфічна рівність:**
    - Об’єкти можна порівнювати лише з іншими об’єктами того ж самого класу.

#### Як це працює:

- Цей трейт інтегрується з `PropertyExtractor`, який отримує список усіх властивостей заданого об’єкта.
- Після цього відбувається порівняння значень властивостей між двома об’єктами.
- Трейт підтримує як підвищені властивості (promoted properties), так і традиційні властивості класів.

#### Метод:

##### `equals(mixed $other): bool`

Визначає, чи є поточний об’єкт рівним іншому об’єкту.

- **Параметри:**
    - `$other` — Об’єкт для порівняння.
- **Повертає:**
    - `true`, якщо об’єкти рівні; інакше `false`.


